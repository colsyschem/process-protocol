#!/usr/bin/env python

"""
A class to calculate number of parameters related to nanoparticles
"""

import os, time
import numpy as np
import pandas as pd

__author__ = "Marek Grzelczak"
__copyright__ = "Copyright 2021, Centro de Fisica de Materiales CSIC-UPV/EHU"
__credits__ = ["Marek Grzelczak"]
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Marek Grzelczak"
__email__ = "grzelczak.marek@gmail.com"
__status__ = "Production"

class nps(object):
    '''
    calculate number, concentration, interparticle distance
    
    Parameters:
    -----------
    length : int, float, required
        units nm
    width : int, float, required
        units nm
    metal_conc : float, required
        concentration of metal atoms.
        units (mol/L)
    volume : int, float, required
        volume of solution
        units mL
    density : float, required
        density of metal
        unit g/cm^3
    metal_mw : float, required
        Molecular mass of metal
        unit g/mol
    dimensionality : int, optional
        dimensionless parameter defining multiple particle state
        1 - nanoparticle chains, 2 - array, 3 - solution
        default 3
    p_light : float, optional
        Power density of ligth, default 150
        unit mW/cm2
    sigma_abs : float, optional
        Absorption cross-section of NP, default 25000 estimated for
        rods of 65x17nm at wavelength = LSPR max
        unit nm2
    kappa_med : float, optional
        thermal conductivity of medium, water as default 0.591
        unit W * m-1 * K-1
    
    References
    -----
    Thermoplasmonics by Baffou
    '''
    
    def __init__(self, 
                 length='', 
                 width='', 
                 metal_conc='',
                 volume='', 
                 density='',
                 metal_mw='',
                 dimensionality=3,
                 p_light=150,
                 sigma_abs=25000,
                 kappa_med=0.591
                ):

        self.length=length
        self.width=width # width
        self.conc=metal_conc # length
        self.vol=volume
        self.mw=metal_mw
        self.m=dimensionality
        
        self.density= density * 10**-21
        self.radius = self.width/2
        
        self.pow_light = p_light * 10000 # convert mW/cm2 to W/m2
        self.sigma = sigma_abs * 1e-18 # convert nm2 to m2

        self.kappa = kappa_med
        
        
    def volume_np(self):
        '''
        unit: nm^3
        '''
        
        volume = np.power(self.radius,2) * np.pi * self.length
        return int(volume)
    
    def surface_np(self):
        '''
        return surface of individiaul nanoparticle
        unit: nm^2
        '''
        
        surface = 2 * np.power(self.radius,2) * np.pi + (2 * np.pi * self.radius * self.length)
        return int(surface)
        
    def num_nps(self):
        
        mole_metal = self.vol * self.conc / 1000
        mass_metal = self.mw * mole_metal
        mass_np = nps.volume_np(self) *  self.density
        return int(mass_metal/mass_np)
    
    def dist_int_nps(self):
        '''
        return avarage interparticle distance
        units: meter
        '''
        volume_segment = self.vol * 0.000001 / nps.num_nps(self)
        edge = np.cbrt(volume_segment)
        diagonal = edge * np.sqrt(3)
        edge_diag = [edge, diagonal]
        return diagonal
    
    def dist(self):
        '''
        return interparticle distance
        units: nanoparticle diameter
        '''
        distance = nps.dist_int_nps(self)/nps.radius_eq(self)*2
        return distance
    
    def mole_nps(self):
        mole_np = nps.num_nps(self)/constants.Avogadro
        return mole_np
        
    def conc_nps(self):
        '''
        return concentration of nanoparticles.
        units mol/mL
        '''
        conc = nps.mole_nps(self) * 1000 / self.vol
        return conc
    
    def surface_total(self):
        '''
        return total surface of metal in solution
        unit: m^2
        '''
        return nps.surface_np(self)*nps.num_nps(self) * 10**-18
    
    def radius_eq(self):
        '''
        return radius of circle of a surface equivalent to the 
        gold nanorods cross section.
        units: meter
        '''
        radius = (3/4 * np.pi * nps.volume_np(self))**(1/3)
        return radius * 0.000000001

    def zeta(self):
        '''
        return dimensionless Z parameter.
        The lower the Z value, the larger the contribution of colective heating 
        '''
        p = nps.dist_int_nps(self) 
        b = nps.radius_eq(self) * nps.num_nps(self)**((self.m-1)/self.m)
        return p/b
    
    def power_np(self):
        '''
        return power generated by nanoparticle in Watts
        '''
        power = self.sigma * self.pow_light                     
#         print(f'power: {power} W')
        return power
    
    def delta_T_self(self):
        sigma_norm = self.sigma / nps.radius_eq(self)           # normalize sigma_abs to geometrical cross-section
        
        geometry = 4 * np.pi * self.kappa * nps.radius_eq(self) # denominator of equation
        delta_T_np = nps.power_np(self) / geometry
        
#         print(f'denominator: {geometry} W/K')
        return delta_T_np
    
    def delta_T_tot(self, n=200):
    
        temps = []
        all_cubes = []
        distances = []
        for i in range(1,n):
            outer_cubes = (6 * i**2) - 12*i + 8
            
            all_cubes.append(outer_cubes)
            
            if sum(all_cubes) > nps.num_nps(self):
                break
            else:
                distance = nps.dist_int_nps(self) * i
                distances.append(distance)
                
                geometry = 4 * np.pi * self.kappa * distance

                temps_outer_shell = [round(nps.power_np(self) / geometry,7) for i in range(1,outer_cubes)]

                temps.append(sum(temps_outer_shell))
                
        delta_T_nps = np.sum(temps, initial=nps.delta_T_self(self))

        return delta_T_nps,all_cubes, sum(all_cubes), temps, distances
        

